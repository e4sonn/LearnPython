const e='# Module 3: Operators - Lesson 7: Operator Precedence\n\nIn mathematics and programming, when an expression contains multiple operators, the order in which these operations are performed is crucial. This order is determined by **operator precedence**. Python, like most programming languages, has a well-defined hierarchy of operator precedence that dictates how expressions are evaluated.\n\nUnderstanding operator precedence helps you correctly interpret expressions and write code that behaves as intended. When in doubt, or to make your code clearer, you can always use parentheses `()` to explicitly control the order of evaluation.\n\n**The Hierarchy of Precedence**\n\nHere is a summary of operator precedence in Python, from highest to lowest. Operators on the same line in this list generally have the same precedence and are evaluated from left to right (unless otherwise specified, like for exponentiation or assignment).\n\n1.  **`()` (Parentheses, Grouping)**: Expressions within parentheses are always evaluated first. This is the most straightforward way to override default precedence.\n2.  **`f(args...)` (Function Calls)**, `x[index]` (Slicing), `x[index:index]` (Subscription), `x.attribute` (Attribute Reference)\n3.  **`**` (Exponentiation)**: Evaluated from right to left (e.g., `2 ** 3 ** 2` is `2 ** (3 ** 2)`, which is `2 ** 9`).\n4.  **`+x`, `-x`, `~x` (Unary Plus, Unary Minus, Bitwise NOT)**\n5.  **`*`, `/`, `//`, `%` (Multiplication, Division, Floor Division, Modulus)**: Evaluated from left to right.\n6.  **`+`, `-` (Addition and Subtraction)**: Evaluated from left to right.\n7.  **`<<`, `>>` (Bitwise Shifts)**: Evaluated from left to right.\n8.  **`&` (Bitwise AND)**: Evaluated from left to right.\n9.  **`^` (Bitwise XOR)**: Evaluated from left to right.\n10. **`|` (Bitwise OR)**: Evaluated from left to right.\n11. **`in`, `not in`, `is`, `is not`, `<`, `<=`, `>`, `>=`, `!=`, `==` (Comparisons, including Membership and Identity Operators)**: These all have the same precedence and support chaining (e.g., `a < b == c`). Chained comparisons are evaluated from left to right.\n12. **`not` (Logical NOT)**\n13. **`and` (Logical AND)**\n14. **`or` (Logical OR)**\n15. **`if-else` (Conditional Expression)**: e.g., `x if C else y`\n16. **`lambda` (Lambda Expression)**\n17. **`=` , `+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=`, `&=`, `|=`, `^=`, `>>=`, `<<=` (Assignment Operators)**: Evaluated from right to left (e.g., `a = b = c = 0`).\n\n**Illustrative Examples**\n\nLet\'s look at how precedence affects the evaluation of some common expressions:\n\n*   **Arithmetic Operators:**\n    ```python\n    result = 10 + 5 * 2\n    # Multiplication (*) has higher precedence than addition (+).\n    # So, 5 * 2 is evaluated first (10).\n    # Then, 10 + 10 is evaluated (20).\n    print(f"10 + 5 * 2 = {result}")  # Output: 20\n\n    result_with_parens = (10 + 5) * 2\n    # Parentheses override default precedence.\n    # (10 + 5) is evaluated first (15).\n    # Then, 15 * 2 is evaluated (30).\n    print(f"(10 + 5) * 2 = {result_with_parens}") # Output: 30\n\n    result_exp = 2 * 3 ** 2\n    # Exponentiation (**) has higher precedence than multiplication (*).\n    # 3 ** 2 is evaluated first (9).\n    # Then, 2 * 9 is evaluated (18).\n    print(f"2 * 3 ** 2 = {result_exp}") # Output: 18\n    ```\n\n*   **Arithmetic and Comparison Operators:**\n    ```python\n    x = 5\n    y = 10\n    is_greater = x + y > 12\n    # Addition (+) has higher precedence than comparison (>).\n    # x + y (5 + 10 = 15) is evaluated first.\n    # Then, 15 > 12 is evaluated (True).\n    print(f"{x} + {y} > 12 is {is_greater}") # Output: 5 + 10 > 12 is True\n    ```\n\n*   **Logical Operators:**\n    ```python\n    a = True\n    b = False\n    c = True\n\n    # Precedence: not > and > or\n    logical_result1 = a or not b and c\n    # 1. not b (not False) -> True\n    # 2. True and c (True and True) -> True\n    # 3. a or True (True or True) -> True\n    print(f"{a} or not {b} and {c} = {logical_result1}") # Output: True or not False and True = True\n\n    # Using parentheses for clarity or different order:\n    logical_result2 = (a or not b) and c\n    # 1. not b -> True\n    # 2. a or True (True or True) -> True\n    # 3. True and c (True and True) -> True\n    print(f"({a} or not {b}) and {c} = {logical_result2}") # Output: (True or not False) and True = True\n\n    # Another example to show difference\n    # Default: False and False or True -> False or True -> True\n    print(False and False or True) # Output: True\n    # With parentheses: False and (False or True) -> False and True -> False\n    print(False and (False or True)) # Output: False\n    ```\n\n*   **Mixed Operators:**\n    ```python\n    age = 20\n    has_id = True\n    is_vip = False\n\n    # Can enter if (age >= 18 and has_id) or is_vip\n    can_enter = age >= 18 and has_id or is_vip\n    # 1. age >= 18 (20 >= 18) -> True\n    # 2. True and has_id (True and True) -> True (due to `and` having higher precedence than `or`)\n    # 3. True or is_vip (True or False) -> True\n    print(f"Can enter: {can_enter}") # Output: Can enter: True\n\n    # If we wanted: age >= 18 AND (has_id OR is_vip)\n    can_enter_alt = age >= 18 and (has_id or is_vip)\n    # 1. has_id or is_vip (True or False) -> True\n    # 2. age >= 18 (True)\n    # 3. True and True -> True\n    print(f"Can enter (alternative logic): {can_enter_alt}") # Output: Can enter (alternative logic): True\n    # In this specific case, both yield True, but the evaluation path differs.\n    ```\n\n**Associativity**\n\nWhen operators have the same precedence, their **associativity** determines the order of evaluation. Most binary operators in Python are **left-associative**. This means they are evaluated from left to right.\n\n```python\nresult = 100 / 10 * 2\n# / and * have the same precedence and are left-associative.\n# 1. 100 / 10 is evaluated first (10.0).\n# 2. Then, 10.0 * 2 is evaluated (20.0).\nprint(f"100 / 10 * 2 = {result}") # Output: 20.0\n\nresult_sub = 10 - 4 - 2\n# - and - have same precedence and are left-associative\n# 1. 10 - 4 is evaluated first (6)\n# 2. Then, 6 - 2 is evaluated (4)\nprint(f"10 - 4 - 2 = {result_sub}") # Output: 4\n```\n\nAn exception is the exponentiation operator (`**`), which is **right-associative**.\n\n```python\nexp_result = 2 ** 3 ** 2\n# ** is right-associative.\n# 1. 3 ** 2 is evaluated first (9).\n# 2. Then, 2 ** 9 is evaluated (512).\nprint(f"2 ** 3 ** 2 = {exp_result}") # Output: 512\n\n# If it were left-associative, it would be (2 ** 3) ** 2 = 8 ** 2 = 64, which is different.\n```\n\nAssignment operators (`=`, `+=`, etc.) are also effectively right-associative in how they group (e.g., `a = b = c = 0` assigns `0` to `c`, then the result of that (`c`) to `b`, then the result of that (`b`) to `a`).\n\n**The Power of Parentheses**\n\nWhile it\'s good to be aware of the operator precedence rules, the best practice for writing clear and unambiguous code is to **use parentheses `()` liberally**. Parentheses explicitly dictate the order of operations, making your code easier for others (and your future self) to read and understand, regardless of how well they remember the precedence table.\n\n```python\n# Less clear without parentheses (relies on knowing precedence of and/or)\ncomplex_condition = x > 5 and y < 10 or z == 0\n\n# Much clearer with parentheses\nclear_condition_1 = (x > 5 and y < 10) or (z == 0)\nclear_condition_2 = x > 5 and (y < 10 or z == 0)\n```\nUsing parentheses removes any doubt about the intended order of evaluation and can prevent subtle bugs that arise from misunderstanding precedence rules.\n\n**Conclusion**\n\nOperator precedence is a fundamental concept in Python that governs how complex expressions are evaluated. While Python has a detailed hierarchy, relying solely on memory for these rules can lead to errors or unreadable code. The most effective strategy is to use parentheses to make the order of operations explicit and ensure your expressions are evaluated as intended. This practice significantly enhances code clarity and maintainability.\n';export{e as default};
