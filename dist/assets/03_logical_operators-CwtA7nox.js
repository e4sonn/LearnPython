const e='# Module 3: Operators - Lesson 3: Logical Operators\n\nIn our previous lessons, we explored arithmetic operators for calculations and comparison operators for evaluating conditions. Now, we delve into **logical operators**. These operators are used to combine or modify Boolean expressions (which evaluate to `True` or `False`). Logical operators are fundamental for creating more complex decision-making logic in your Python programs.\n\nPython has three main logical operators: `and`, `or`, and `not`.\n\n**1. `and` Operator**\n\nThe `and` operator returns `True` if **both** the Boolean expressions on its left and right sides are `True`. If either or both expressions are `False`, the `and` operator returns `False`.\n\nThink of it as requiring all conditions to be met.\n\n**Truth Table for `and`:**\n\n| Operand 1 | Operand 2 | `Operand1 and Operand2` |\n| :-------- | :-------- | :---------------------- |\n| `True`    | `True`    | `True`                  |\n| `True`    | `False`   | `False`                 |\n| `False`   | `True`    | `False`                 |\n| `False`   | `False`   | `False`                 |\n\n**Examples:**\n\n```python\nage = 25\nhas_valid_id = True\n\n# Condition: To enter a venue, age must be 18 or over AND must have a valid ID.\ncan_enter_venue = (age >= 18) and (has_valid_id == True)\n# (25 >= 18) is True. (has_valid_id == True) is True.\n# True and True results in True.\nprint(f"Can enter venue: {can_enter_venue}")  # Output: Can enter venue: True\n\ncredits_completed = 110\ngpa = 3.2\n\n# Condition: To graduate with honors, credits must be >= 120 AND GPA must be >= 3.5\ncan_graduate_honors = (credits_completed >= 120) and (gpa >= 3.5)\n# (110 >= 120) is False. (3.2 >= 3.5) is False.\n# False and False results in False (even if one was True, the result would still be False).\nprint(f"Can graduate with honors: {can_graduate_honors}") # Output: Can graduate with honors: False\n\nis_sunny = True\nis_warm = False\nperfect_beach_day = is_sunny and is_warm\n# True and False results in False\nprint(f"Perfect beach day: {perfect_beach_day}") # Output: Perfect beach day: False\n```\n\n**2. `or` Operator**\n\nThe `or` operator returns `True` if **at least one** of the Boolean expressions on its left or right side is `True`. It only returns `False` if both expressions are `False`.\n\nThink of it as requiring only one of several conditions to be met.\n\n**Truth Table for `or`:**\n\n| Operand 1 | Operand 2 | `Operand1 or Operand2` |\n| :-------- | :-------- | :--------------------- |\n| `True`    | `True`    | `True`                 |\n| `True`    | `False`   | `True`                 |\n| `False`   | `True`    | `True`                 |\n| `False`   | `False`   | `False`                |\n\n**Examples:**\n\n```python\nhas_ticket = False\nis_on_guest_list = True\n\n# Condition: To enter a concert, you either need a ticket OR be on the guest list.\ncan_enter_concert = has_ticket or is_on_guest_list\n# False or True results in True.\nprint(f"Can enter concert: {can_enter_concert}")  # Output: Can enter concert: True\n\nis_weekend = True\nhas_holiday = False\n\n# Condition: Day off from work if it is the weekend OR it is a holiday.\nday_off = is_weekend or has_holiday\n# True or False results in True.\nprint(f"Is it a day off? {day_off}") # Output: Is it a day off? True\n\nneeds_milk = False\nneeds_bread = False\nneeds_to_go_shopping = needs_milk or needs_bread\n# False or False results in False.\nprint(f"Needs to go shopping: {needs_to_go_shopping}") # Output: Needs to go shopping: False\n```\n\n**3. `not` Operator**\n\nThe `not` operator is a unary operator, meaning it operates on only one Boolean operand. It reverses the Boolean value of its operand. If the operand is `True`, `not` makes it `False`. If the operand is `False`, `not` makes it `True`.\n\n**Truth Table for `not`:**\n\n| Operand | `not Operand` |\n| :------ | :------------ |\n| `True`  | `False`       |\n| `False` | `True`        |\n\n**Examples:**\n\n```python\nis_raining = True\nnot_raining = not is_raining\n# not True results in False.\nprint(f"Is it not raining? {not_raining}")  # Output: Is it not raining? False\n\nis_logged_in = False\naccess_denied = not is_logged_in\n# not False results in True.\nprint(f"Is access denied? {access_denied}") # Output: Is access denied? True\n```\n\n**Combining Logical Operators**\n\nYou can combine multiple logical operators in a single expression to create complex conditions. When doing so, it\'s important to understand operator precedence or use parentheses `()` to clarify the order of evaluation.\n\nThe order of precedence for logical operators is:\n1.  `not` (highest precedence)\n2.  `and`\n3.  `or` (lowest precedence)\n\n```python\nscore = 75\nattendance = 0.90  # 90% attendance\nis_project_submitted = True\n\n# Condition for passing a course:\n# (Score must be >= 70 AND attendance must be >= 0.80) OR project must be submitted.\n\n# Without parentheses, `and` is evaluated before `or`:\n# (score >= 70 and attendance >= 0.80) or is_project_submitted\n\npassed_course = score >= 70 and attendance >= 0.80 or is_project_submitted\n# (True and True) or True\n# True or True -> True\nprint(f"Passed course (default precedence): {passed_course}") # Output: True\n\n# Using parentheses for clarity or to change order:\n# Example: Student passes if project is submitted AND (score is high OR attendance is good)\nstudent_effort_pays_off = is_project_submitted and (score >= 85 or attendance >= 0.95)\n# True and (False or False)\n# True and False -> False\nprint(f"Student effort pays off: {student_effort_pays_off}") # Output: False\n```\nUsing parentheses, even when not strictly necessary due to default precedence, can greatly improve the readability of complex logical expressions.\n\n**Short-Circuit Evaluation**\n\nPython\'s logical operators (`and`, `or`) use **short-circuit evaluation**. This means that the second operand is only evaluated if the first operand is not enough to determine the result of the entire expression.\n\n*   **For `and`**: If the first operand evaluates to `False`, the entire `and` expression must be `False` (because `False and Anything` is always `False`). So, Python does not evaluate the second operand.\n\n    ```python\n    x = 5\n    y = 0\n\n    # If y was 0, x / y would cause a ZeroDivisionError.\n    # However, because (x < 0) is False, the second part (x / y > 1) is not evaluated.\n    result = (x < 0) and (x / y > 1) # (x < 0) is False. Short-circuits.\n    print(f"Short-circuit with \'and\': {result}") # Output: False\n    ```\n\n*   **For `or`**: If the first operand evaluates to `True`, the entire `or` expression must be `True` (because `True or Anything` is always `True`). So, Python does not evaluate the second operand.\n\n    ```python\n    x = 10\n    # y = 0 # Let\'s imagine y could cause an error if used\n\n    # Because (x > 0) is True, the second part (potentially problematic_function()) is not evaluated.\n    # def potentially_problematic_function():\n    #     print("Problematic function called!")\n    #     return 1 / 0 # This would cause an error\n\n    result = (x > 0) or (potentially_problematic_function() > 1) # (x > 0) is True. Short-circuits.\n    print(f"Short-circuit with \'or\': {result}") # Output: True\n    # "Problematic function called!" will NOT be printed.\n    ```\nShort-circuiting is not just an optimization; it can be used intentionally to prevent errors, like dividing by zero or calling functions that should only be called if a prior condition is met.\n\n**Logical Operators with Non-Boolean Operands (Truthiness/Falsiness)**\n\nLogical operators can also work with non-Boolean operands. In such cases, Python uses the concept of "truthiness" and "falsiness" we discussed earlier.\n\n*   `x and y`: If `x` is Falsy, returns `x`. Otherwise (if `x` is Truthy), returns `y`.\n*   `x or y`: If `x` is Truthy, returns `x`. Otherwise (if `x` is Falsy), returns `y`.\n*   `not x`: Returns `False` if `x` is Truthy, and `True` if `x` is Falsy.\n\n```python\n# \'and\' with non-Booleans\nresult_and1 = 0 and "Hello"  # 0 is Falsy, so it returns 0\nprint(f"0 and \\"Hello\\": {result_and1}")\n\nresult_and2 = "Hi" and "Python" # "Hi" is Truthy, so it returns "Python"\nprint(f"\\"Hi\\" and \\"Python\\": {result_and2}")\n\n# \'or\' with non-Booleans\nresult_or1 = 0 or "Hello"    # 0 is Falsy, so it returns "Hello"\nprint(f"0 or \\"Hello\\": {result_or1}")\n\nresult_or2 = "Hi" or "Python"   # "Hi" is Truthy, so it returns "Hi"\nprint(f"\\"Hi\\" or \\"Python\\": {result_or2}")\n\n# \'not\' with non-Booleans\nresult_not1 = not 0          # 0 is Falsy, so not 0 is True\nprint(f"not 0: {result_not1}")\n\nresult_not2 = not "Text"     # "Text" is Truthy, so not "Text" is False\nprint(f"not \\"Text\\": {result_not2}")\n```\nThis behavior is sometimes used for concise conditional assignments or providing default values, but it can make code harder to read if overused. For clarity, it\'s often better to use explicit `if-else` statements when the logic involves non-Boolean outcomes.\n\n**Conclusion**\n\nLogical operators (`and`, `or`, `not`) are indispensable for building complex conditions in Python. They allow you to combine multiple Boolean expressions, control program flow based on sophisticated criteria, and leverage short-circuit evaluation for efficiency and error prevention. A solid understanding of these operators is key to writing programs that can make intelligent decisions.\n';export{e as default};
