const t='# Module 2: Variables and Data Types - Lesson 6: Type Conversion (Casting)\n\nThroughout our exploration of variables and data types, we\'ve seen that Python handles different kinds of data, such as numbers, strings, and Booleans. We also briefly touched upon the idea that `input()` always gives us a string, even if the user types numbers. This brings us to an important concept: **type conversion**, also known as **type casting**.\n\nType conversion is the process of changing a value from one data type to another. Python is dynamically typed, meaning it often figures out the data types automatically. However, there are many situations where you, as a programmer, need to explicitly convert data from one type to another to perform certain operations or to ensure your program behaves as expected.\n\n**Why is Type Conversion Necessary?**\n\n1.  **User Input:** As we\'ve learned, the `input()` function always returns a string. If you ask a user for their age and they type "25", Python sees it as the string `"25"`, not the number `25`. To perform mathematical calculations (like `age + 1`), you must convert this string to a numeric type (e.g., `int`).\n\n2.  **Performing Operations:** Different data types support different operations. You can add two numbers, but adding a number to a string directly will usually result in a `TypeError` (unless you intend string concatenation, which requires both operands to be strings).\n    ```python\n    # num = 10\n    # text = "Score: "\n    # result = text + num  # This would cause a TypeError\n    ```\n    To combine them, you might convert the number to a string: `result = text + str(num)`.\n\n3.  **Data Compatibility:** When working with data from various sources (files, databases, web APIs), the data might not be in the exact type you need for your processing. Type conversion helps ensure compatibility.\n\n**Built-in Type Conversion Functions**\n\nPython provides several built-in functions to perform explicit type conversions. These functions generally take a value of one type as an argument and return a new value of the desired type. If the conversion is not possible, they usually raise a `ValueError` or `TypeError`.\n\nHere are the most common conversion functions:\n\n*   **`int(x)`**: Converts `x` to an integer.\n    *   If `x` is a float, it truncates the decimal part (e.g., `int(7.8)` becomes `7`).\n    *   If `x` is a string, the string must represent a whole number (e.g., `"123"`). Strings like `"12.3"` or `"hello"` will cause a `ValueError`.\n    *   If `x` is a Boolean, `int(True)` is `1` and `int(False)` is `0`.\n\n    ```python\n    float_num = 123.789\n    int_from_float = int(float_num)\n    print(f"int({float_num}) = {int_from_float}")  # Output: int(123.789) = 123\n\n    str_num = "456"\n    int_from_str = int(str_num)\n    print(f"int(\\"{str_num}\\") = {int_from_str}")    # Output: int("456") = 456\n\n    # print(int("456.7")) # This would raise a ValueError\n    # print(int("Python")) # This would raise a ValueError\n\n    bool_true = True\n    int_from_bool = int(bool_true)\n    print(f"int({bool_true}) = {int_from_bool}")    # Output: int(True) = 1\n    ```\n\n*   **`float(x)`**: Converts `x` to a floating-point number.\n    *   If `x` is an integer, it adds a decimal part (e.g., `float(10)` becomes `10.0`).\n    *   If `x` is a string, the string must represent a valid number, which can include a decimal point (e.g., `"123"` or `"123.45"`). Strings like `"hello"` will cause a `ValueError`.\n    *   If `x` is a Boolean, `float(True)` is `1.0` and `float(False)` is `0.0`.\n\n    ```python\n    int_val = 789\n    float_from_int = float(int_val)\n    print(f"float({int_val}) = {float_from_int}") # Output: float(789) = 789.0\n\n    str_float = "78.91"\n    float_from_str = float(str_float)\n    print(f"float(\\"{str_float}\\") = {float_from_str}") # Output: float("78.91") = 78.91\n\n    str_int_like = "123"\n    float_from_int_str = float(str_int_like)\n    print(f"float(\\"{str_int_like}\\") = {float_from_int_str}") # Output: float("123") = 123.0\n    ```\n\n*   **`str(x)`**: Converts `x` to a string representation.\n    *   This function works for almost any data type in Python. It returns a human-readable string version of the object.\n\n    ```python\n    num_val = 100\n    str_from_num = str(num_val)\n    print(f"str({num_val}) = \\"{str_from_num}\\"") # Output: str(100) = "100"\n\n    pi = 3.14159\n    str_from_float = str(pi)\n    print(f"str({pi}) = \\"{str_from_float}\\"") # Output: str(3.14159) = "3.14159"\n\n    my_list = [1, 2, 3]\n    str_from_list = str(my_list)\n    print(f"str({my_list}) = \\"{str_from_list}\\"") # Output: str([1, 2, 3]) = "[1, 2, 3]"\n    ```\n\n*   **`bool(x)`**: Converts `x` to a Boolean value (`True` or `False`).\n    *   We discussed "truthiness" and "falsiness" in the Booleans lesson. `bool()` formalizes this.\n    *   Values like `0`, `0.0`, `None`, empty strings (`""`), empty lists (`[]`), empty tuples (`()`), empty dictionaries (`{}`), and empty sets (`set()`) convert to `False`.\n    *   Most other values, including non-zero numbers and non-empty sequences/mappings, convert to `True`.\n\n    ```python\n    print(f"bool(0) = {bool(0)}")             # Output: bool(0) = False\n    print(f"bool(15) = {bool(15)}")           # Output: bool(15) = True\n    print(f"bool(\\"\\") = {bool("")}")           # Output: bool("") = False\n    print(f"bool(\\"Hi\\") = {bool("Hi")}")         # Output: bool("Hi") = True\n    print(f"bool([]) = {bool([])}")           # Output: bool([]) = False\n    print(f"bool(None) = {bool(None)}")       # Output: bool(None) = False\n    ```\n\n*   **`list(x)`**: Converts an iterable `x` (like a string, tuple, or set) to a list.\n*   **`tuple(x)`**: Converts an iterable `x` (like a string, list, or set) to a tuple.\n*   **`set(x)`**: Converts an iterable `x` (like a string, list, or tuple) to a set (duplicates will be removed).\n\n    ```python\n    my_string = "hello"\n    list_from_string = list(my_string)\n    print(f"list(\\"{my_string}\\") = {list_from_string}") # Output: list("hello") = ["h", "e", "l", "l", "o"]\n\n    my_tuple = (1, 2, 2, 3, 4)\n    set_from_tuple = set(my_tuple)\n    print(f"set({my_tuple}) = {set_from_tuple}") # Output: set((1, 2, 2, 3, 4)) = {1, 2, 3, 4}\n\n    my_list = ["a", "b", "c"]\n    tuple_from_list = tuple(my_list)\n    print(f"tuple({my_list}) = {tuple_from_list}") # Output: tuple(["a", "b", "c"]) = ("a", "b", "c")\n    ```\n\n**Handling Potential Errors during Conversion**\n\nAs mentioned, attempting an invalid conversion (e.g., `int("hello")`) will raise a `ValueError`. In real-world programs, especially when dealing with user input or data from external sources, it\'s crucial to anticipate these errors and handle them gracefully using `try-except` blocks.\n\n```python\nuser_value = input("Enter a number: ")\n\ntry:\n    numeric_value = float(user_value)\n    print(f"You entered the number: {numeric_value}")\n    print(f"Double your number is: {numeric_value * 2}")\nexcept ValueError:\n    print(f"Error: \r√°sok{user_value}" is not a valid number. Please enter digits only.")\n```\nThis `try-except` structure attempts the conversion. If a `ValueError` occurs, the code in the `except` block is executed, preventing the program from crashing and providing a helpful message to the user.\n\n**Implicit Type Conversion (Coercion)**\n\nSometimes, Python performs type conversion automatically. This is called implicit type conversion or coercion. It usually happens in arithmetic operations involving different numeric types. For example, if you add an integer and a float, Python will implicitly convert the integer to a float before performing the addition, and the result will be a float.\n\n```python\nint_num = 5\nfloat_num = 2.5\n\nresult = int_num + float_num # Python converts int_num (5) to 5.0\nprint(f"Result: {result}")       # Output: Result: 7.5\nprint(f"Type of result: {type(result)}") # Output: Type of result: <class "float">\n```\nPython generally tries to convert to the \n\nmore general type to avoid loss of information (e.g., int to float, not float to int, as the latter would lose the decimal part).\n\nHowever, rely on explicit conversion when your intent might be ambiguous or when dealing with non-numeric types (like strings).\n\n**Conclusion**\n\nType conversion is a fundamental skill in Python programming. It allows you to manipulate data of different types effectively and integrate data from various sources.\n*   Use built-in functions like `int()`, `float()`, `str()`, and `bool()` for explicit conversions.\n*   Always be mindful that `input()` returns strings, requiring conversion for numerical operations.\n*   Employ `try-except` blocks to handle potential `ValueError` exceptions during conversions, especially with user input.\n*   Understand that Python performs some implicit conversions (coercion) with numeric types, but explicit conversion is often clearer and safer.\n\nMastering type conversion will make your Python code more robust, flexible, and less prone to unexpected type-related errors. As you write more programs, you\'ll find yourself using these conversion functions frequently.\n';export{t as default};
