const e='# Module 4: Control Flow - Conditional Statements - Lesson 3: The `if-elif-else` Statement (Chained Conditionals)\n\nWe\'ve learned how to make decisions with `if` statements (for a single condition) and `if-else` statements (for two alternative paths). But what if you have more than two possible outcomes or need to check multiple conditions in sequence? This is where the **`if-elif-else` statement** (often called chained conditionals) becomes incredibly useful.\n\n**What is an `if-elif-else` Statement?**\n\nThe `if-elif-else` statement allows you to check multiple conditions one by one. As soon as one of the conditions is found to be `True`, the corresponding block of code is executed, and the rest of the chain (subsequent `elif` and `else` blocks) is skipped. If none of the `if` or `elif` conditions are `True`, the optional `else` block at the end is executed.\n\n`elif` is short for "else if."\n\n**Syntax of the `if-elif-else` Statement**\n\nThe general structure is as follows:\n\n```python\nif condition1:\n    # Block of code to execute if condition1 is True\n    statement_block_1\nelif condition2:\n    # Block of code to execute if condition1 is False AND condition2 is True\n    statement_block_2\nelif condition3:\n    # Block of code to execute if condition1 and condition2 are False AND condition3 is True\n    statement_block_3\n# ... you can have as many elif clauses as needed ...\nelse:\n    # Optional block of code to execute if ALL preceding conditions (if and elifs) are False\n    statement_block_else\n\n# Code here executes after one of the blocks in the chain (or none if no else and all false) has executed\n```\n\nKey components:\n\n1.  **`if condition1:`**: The chain starts with an `if` statement, followed by its condition and a colon.\n2.  **`elif conditionX:`**: You can have one or more `elif` clauses. Each `elif` has its own condition and a colon. An `elif` block is only checked if all preceding `if` and `elif` conditions were `False`.\n3.  **Indented Blocks**: Each `if`, `elif`, and `else` clause has its own indented block of code.\n4.  **`else:` (Optional)**: An optional `else` clause can be placed at the end. Its block executes if none of the `if` or `elif` conditions were `True`. There can be at most one `else` clause in an `if-elif-else` chain.\n\n**How it Works**\n\n1.  Python evaluates `condition1`.\n2.  If `condition1` is `True`, `statement_block_1` is executed, and the entire `if-elif-else` chain is exited. Subsequent `elif` and `else` blocks are skipped.\n3.  If `condition1` is `False`, Python proceeds to evaluate `condition2` of the first `elif` clause.\n4.  If `condition2` is `True`, `statement_block_2` is executed, and the chain is exited.\n5.  This process continues for each `elif` clause in sequence. As soon as an `elif` condition is found to be `True`, its block is executed, and the rest of the chain is skipped.\n6.  If all `if` and `elif` conditions evaluate to `False`, and an `else` clause is present, `statement_block_else` is executed.\n7.  If all `if` and `elif` conditions are `False` and there is no `else` clause, then none of the blocks within the chain are executed, and the program simply moves on to the next statement after the chain.\n\n**Important: Only one block (at most) in the entire `if-elif-else` chain will be executed.**\n\n**Examples of `if-elif-else` Statements**\n\nLet\'s illustrate with some common scenarios:\n\n```python\n# Example 1: Grading system based on score\nscore = 75\n\nif score >= 90:\n    grade = "A"\n    print("Excellent work!")\nelif score >= 80:\n    grade = "B"\n    print("Good job!")\nelif score >= 70:\n    grade = "C"\n    print("Satisfactory.")\nelif score >= 60:\n    grade = "D"\n    print("Needs improvement.")\nelse:\n    grade = "F"\n    print("Please see the instructor.")\n\nprint(f"Your score is {score}, and your grade is {grade}.")\n\n# If score is 75:\n# - 75 >= 90 is False.\n# - 75 >= 80 is False.\n# - 75 >= 70 is True. So, grade becomes "C", "Satisfactory." is printed.\n# - The remaining elif and else are skipped.\n# Output: Satisfactory.\n#         Your score is 75, and your grade is C.\n```\n\n```python\n# Example 2: Responding to user input for a menu choice\nprint("Menu:")\nprint("1. View Profile")\nprint("2. Edit Settings")\nprint("3. Logout")\nchoice_str = input("Enter your choice (1-3): ")\n\nif choice_str == "1":\n    print("Displaying your profile...")\nelif choice_str == "2":\n    print("Opening settings editor...")\nelif choice_str == "3":\n    print("Logging you out...")\nelse:\n    print("Invalid choice. Please enter a number between 1 and 3.")\n```\n\n```python\n# Example 3: Determining the type of a number (positive, negative, or zero)\nnumber = -5\n\nif number > 0:\n    print(f"{number} is positive.")\nelif number < 0:\n    print(f"{number} is negative.")\nelse: # This covers the only remaining case: number == 0\n    print(f"{number} is zero.")\n\n# Output for number = -5: "-5 is negative."\n```\n\n**Order Matters**\n\nThe order of the `elif` clauses is important because Python checks them sequentially. If multiple `elif` conditions could be true for a given input, only the block associated with the *first* one encountered that evaluates to `True` will be executed.\n\nConsider this slightly modified grading example:\n\n```python\nscore = 95\n\n# Potentially problematic order if not careful\nif score >= 70: # This is True for score = 95\n    grade = "C (or better)"\nelif score >= 80:\n    grade = "B (or better)"\nelif score >= 90:\n    grade = "A"\nelse:\n    grade = "F"\n\nprint(f"Grade: {grade}") # Output: Grade: C (or better)\n```\nIn the example above, because `score >= 70` is checked first and is true for `score = 95`, the first block is executed, and the more specific checks for `score >= 80` or `score >= 90` are never reached. To get the correct specific grade, you should order the conditions from most specific (highest score) to least specific (lowest score), or ensure conditions are mutually exclusive if order doesn\'t inherently provide that.\n\nThe first grading example was correctly ordered:\n`if score >= 90: ... elif score >= 80: ...`\nHere, if a score is 95, `score >= 90` is true, and the `elif score >= 80` is correctly skipped.\n\n**When to Use `if-elif-else` vs. Multiple `if` Statements**\n\n*   Use an **`if-elif-else` chain** when you have a set of mutually exclusive conditions, and you want only one block of code to execute.\n*   Use **multiple independent `if` statements** when you want to check several different conditions, and it\'s possible for more than one of them to be true and for their corresponding blocks to execute independently.\n\n```python\n# Example: Multiple independent if statements\nuser_preferences = ["email_notifications", "sms_alerts"]\n\nif "email_notifications" in user_preferences:\n    print("Sending email notification.")\n\nif "sms_alerts" in user_preferences:\n    print("Sending SMS alert.")\n\nif "push_notifications" in user_preferences: # This condition is false\n    print("Sending push notification.")\n\n# Output:\n# Sending email notification.\n# Sending SMS alert.\n```\nIn this case, both the email and SMS blocks could execute if both preferences are present. This is different from an `if-elif-else` structure where only one path is taken.\n\n**Conclusion**\n\nThe `if-elif-else` statement is a powerful tool for handling multiple conditions and choosing one specific path of execution from several alternatives. It provides a clear and structured way to implement complex decision-making logic in your Python programs. Remember the importance of the order of `elif` clauses and the fact that only one block in the entire chain will ultimately be executed. This structure is fundamental for creating programs that can respond intelligently to a variety of inputs and states.\n';export{e as default};
